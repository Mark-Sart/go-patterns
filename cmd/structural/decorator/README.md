# Паттерн "Декоратор"  
## Определение  
Динамически наделяет объект новыми возможностями, и является гибкой
альтернативой субклассированию (наследованию) в области расширения
функциональности.  
  
## Используемые принципы  
1. Инкапсулируйте то, что изменяется  
2. Отдавайте предпочтение композиции перед наследованием  
3. Программируйте на уровне интерфейсов, а не реализаций  
4. Классны должны быть открыты для расширения, но закрыты для
изменения  
  
## Описание примера  
Реализация паттерна показа на примере кофейни. Существует несколько
видов напитков, а также несколько видов дополнений и размеров
стакана. У каждого напитка свой класс, наследуемый от общего класса.
Если реализовывать для каждой комбинации стакан-напиток-дополнение
свой класс, то в скором времени будет огромное количество классов.
Такой код станет практически невозможно поддерживать.  
  
В этой ситуации приходит на помощь паттерн "Декоратор". Каждое
дополнение имеет свой класс, реализующий общий интерфейс напитка
(или же наследующийся от общего класса). У класса дополнения есть
свойство, которое хранит в себе ссылку на напиток. Также данный
класс реализует методы получения описания и стоимости. К примеру,
стоимость рассчитывается путем сложения стоимости дополнения и
результата метода получения стоимости у сохраненного напитка.
Аналогично работает и метод получения описания.  
  
## Ключевые моменты  
1. Паттерн "Декоратор" предоставляет альтернативу наследованию в
области расширения поведения  
2. Типы декораторов соответствуют типам декорируемых компонентов
(соответствие  достигается посредством наследования или реализации
интерфейса)  
3. Декораторы изменяют поведение компонента, добавляя новую
функциональность до и (или) после (или даже вместо) вызовов методов
компонентов  
4. Компонент может декорироваться любым количеством декораторов  
5. Декораторы обычно прозрачны для клиентов компонента (если
клиентский код не зависит от конкретного типа компонента)  
  
Также существует ряд недостатков данного паттерна:  
1. Может быть создано довольно большое количество
классов-декораторов и тогда становится тяжелее
ориентироваться в проекте  
2. Декораторы не подходя для проекта, чья архитектура зависит от
реализации компонента  