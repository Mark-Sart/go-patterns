# Паттерн "Декоратор"  
## Определение  
Динамически наделяет объект новыми возможностями, и является гибкой
альтернативой субклассированию (наследованию) в области расширения
функциональности.  
  
## Используемые принципы  
1. Инкапсулируйте то, что изменяется  
2. Отдавайте предпочтение композиции перед наследованием  
3. Программируйте на уровне интерфейсов, а не реализаций  
4. Классны должны быть открыты для расширения, но закрыты для
изменения  
  
## Описание примера  
Реализация паттерна показа на примере кофейни. Существует несколько
видов напитков, а также несколько видов дополнений и размеров
стакана. У каждого напитка свой класс, наследуемый от общего класса.
Если реализовывать для каждой комбинации стакан-напиток-дополнение
свой класс, то в скором времени будет огромное количество классов.
Такой код станет практически невозможно поддерживать.  
  
В этой ситуации приходит на помощь паттерн "Декоратор". Каждое
дополнение имеет свой класс, реализующий общий интерфейс напитка
(или же наследующийся от общего класса). У класса дополнения есть
свойство, которое хранит в себе ссылку на напиток. Также данный
класс реализует методы получения описания и стоимости. К примеру,
стоимость рассчитывается путем сложения стоимости дополнения и
результата метода получения стоимости у сохраненного напитка.
Аналогично работает и метод получения описания.  
  
Теперь для создания латте с двойным молоком и шоколадом нет
необходимости создавать новый класс. Достаточно создать объект
класса "Латте", реализующего интерфейс "Напиток", обернуть
его в декоратор "Молоко" и получить новый напиток. Данный напиток
необходимо снова обернуть в декоратор "Молоко" и полученный напиток
обернуть уже в декоратор "Шоколад". В итоге получится объект,
реализующий интерфейс "Напиток" и имеющий методы получения
стоимости и описания.  
  
Обернуть - значит создать объект определенного класса декоратора
и положить в его свойство для хранения оригинального напитка тот
напиток, который оборачивается.  
  
Расчет стоимости происходит путем сложения стоимости дополнения и
результата получения стоимости сохраненного напитка:  
15 + (15 + (10 + (60))), где () - получение стоимости сохраненного
напитка.  
Аналогично происходит получение описания напитка.  
  
## Ключевые моменты  
1. Паттерн "Декоратор" предоставляет альтернативу наследованию в
области расширения поведения  
2. Типы декораторов соответствуют типам декорируемых компонентов
(соответствие  достигается посредством наследования или реализации
интерфейса)  
3. Декораторы изменяют поведение компонента, добавляя новую
функциональность до и (или) после (или даже вместо) вызовов методов
компонентов  
4. Компонент может декорироваться любым количеством декораторов  
5. Декораторы обычно прозрачны для клиентов компонента (если
клиентский код не зависит от конкретного типа компонента)  
  
Также существует несколько недостатков данного паттерна:  
1. Может быть создано довольно большое количество
классов-декораторов и тогда становится тяжело
ориентироваться в проекте  
2. Декораторы не подходят для проекта, чья архитектура зависит от
реализации компонента  